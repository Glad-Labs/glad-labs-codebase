"""
ARCHIVED: October 26, 2025 (Phase 5)
REASON: Migrated to REST API backend
LOCATION: archive/google-cloud-services/content_agent_pubsub_client.py.archive

This was the Pub/Sub client for content_agent
Agent-specific listener for pause/resume commands

MIGRATION NOTES:
- listen_for_messages() → WebSocket listener or REST API polling endpoint (GET /api/agent-commands)
- message_callback() → REST API endpoint handler
- PAUSE_AGENT command → PUT /api/agent-status with {"paused": true}
- RESUME_AGENT command → PUT /api/agent-status with {"paused": false}

Topics (Pub/Sub) → Endpoints (REST API):
- agent-commands → GET /api/agent-commands (polling or WebSocket)
- subscriptions → Database table for command persistence

Classes:
- PubSubClient: Agent-specific Pub/Sub message listener

RE-ACTIVATION PROCESS (if Pub/Sub needed in future):
1. Copy this file back to src/agents/content_agent/services/pubsub_client.py
2. Install google-cloud-pubsub: pip install google-cloud-pubsub
3. Set GCP_PROJECT_ID, GCP_PUBSUB_TOPIC, GCP_PUBSUB_SUBSCRIPTION env vars
4. Update content_agent to initialize and use PubSubClient
5. Create Pub/Sub topic and subscription in GCP
6. Test with Pub/Sub emulator first
7. Start background listener thread: client.listen_for_messages()

FULL ORIGINAL CODE:
"""

import os
import json
import logging
import threading
from concurrent.futures import TimeoutError
from google.cloud import pubsub_v1
from agents.content_agent.config import config
from typing import Callable


class PubSubClient:
    """
    Client for publishing and subscribing to Google Cloud Pub/Sub topics.
    
    MIGRATED TO: REST API with polling or WebSocket (October 26, 2025)
    """

    def __init__(
        self,
        project_id: str,
        topic_id: str,
        subscription_id: str,
        orchestrator,
    ):
        """
        Initializes the Pub/Sub client with publisher and subscriber clients.

        Args:
            project_id (str): GCP project ID
            topic_id (str): Pub/Sub topic ID
            subscription_id (str): Pub/Sub subscription ID
            orchestrator: Reference to agent orchestrator for pause/resume
        """
        self.project_id = project_id
        self.topic_id = topic_id
        self.subscription_id = subscription_id
        self.orchestrator = orchestrator

        self.publisher_client = pubsub_v1.PublisherClient()
        self.subscriber_client = pubsub_v1.SubscriberClient()

        self.topic_path = self.publisher_client.topic_path(project_id, topic_id)
        self.subscription_path = self.subscriber_client.subscription_path(
            project_id, subscription_id
        )

        self._ensure_topic_and_subscription()

        self.listening = False
        self.listener_thread = None

        logging.info("PubSub client initialized.")

    def _ensure_topic_and_subscription(self):
        """
        Creates the topic and subscription if they don't exist.
        """
        try:
            # Create topic if it doesn't exist
            try:
                self.publisher_client.create_topic(request={"name": self.topic_path})
                logging.info(f"Created topic: {self.topic_path}")
            except Exception as e:
                if "ALREADY_EXISTS" not in str(e):
                    logging.warning(f"Topic may already exist: {e}")

            # Create subscription if it doesn't exist
            try:
                self.subscriber_client.create_subscription(
                    request={
                        "name": self.subscription_path,
                        "topic": self.topic_path,
                    }
                )
                logging.info(f"Created subscription: {self.subscription_path}")
            except Exception as e:
                if "ALREADY_EXISTS" not in str(e):
                    logging.warning(f"Subscription may already exist: {e}")

        except Exception as e:
            logging.error(f"Error ensuring topic and subscription: {e}")

    def listen_for_messages(self):
        """
        Listens for messages on the Pub/Sub subscription in a background thread.
        MIGRATED TO: GET /api/agent-commands (polling) or WebSocket listener

        This method starts a background thread that continuously listens for
        incoming messages on the subscription and processes them via the
        callback function.
        """
        if self.listening:
            logging.warning("Already listening for messages.")
            return

        self.listening = True

        def message_stream():
            """Run the subscription listener in the background."""
            try:
                logging.info("Starting Pub/Sub message listener...")
                streaming_pull_future = self.subscriber_client.subscribe(
                    self.subscription_path, callback=self.message_callback
                )

                # Timeout for the streaming pull in seconds
                timeout = 0  # Run indefinitely
                try:
                    streaming_pull_future.result(timeout=timeout)
                except TimeoutError:
                    streaming_pull_future.cancel()
                    logging.info("Message listener timeout.")
            except Exception as e:
                logging.error(f"Error in message stream: {e}")
            finally:
                self.listening = False

        # Start the listener in a background thread
        self.listener_thread = threading.Thread(target=message_stream, daemon=True)
        self.listener_thread.start()
        logging.info("Message listener thread started.")

    def message_callback(self, message):
        """
        Callback function to handle incoming messages from Pub/Sub.
        MIGRATED TO: REST API endpoint handler

        Processes PAUSE_AGENT and RESUME_AGENT commands by setting
        the orchestrator's paused flag accordingly.

        Args:
            message: The Pub/Sub message object
        """
        try:
            message_data = json.loads(message.data.decode("utf-8"))
            command = message_data.get("command", "")

            logging.info(f"Received command from Pub/Sub: {command}")

            if command == "PAUSE_AGENT":
                self.orchestrator.paused = True
                logging.info("Agent has been paused via Pub/Sub command.")

            elif command == "RESUME_AGENT":
                self.orchestrator.paused = False
                logging.info("Agent has been resumed via Pub/Sub command.")

            else:
                logging.warning(f"Unknown command: {command}")

            # Acknowledge the message
            message.ack()

        except Exception as e:
            logging.error(f"Error processing Pub/Sub message: {e}")
            message.nack()  # Negative acknowledgement to retry
