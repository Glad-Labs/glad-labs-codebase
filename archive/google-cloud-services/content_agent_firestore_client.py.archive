"""
ARCHIVED: October 26, 2025 (Phase 5)
REASON: Migrated to REST API backend
LOCATION: archive/google-cloud-services/content_agent_firestore_client.py.archive

This was the Firestore client for content_agent
Agent-specific wrapper around Firestore for task and run logging

MIGRATION NOTES:
- log_run() → POST /api/tasks/{task_id}/runs
- update_run() → PUT /api/tasks/{task_id}/runs/{run_id}
- update_document() → PUT /api/tasks/{task_id}
- get_content_queue() → GET /api/tasks?status=New
- update_task_status() → PUT /api/tasks/{task_id}
- add_log_to_run() → POST /api/tasks/{task_id}/runs/{run_id}/logs
- add_task() → POST /api/tasks

Collections (Firestore) → Endpoints (REST API):
- agent_runs → /api/tasks/{task_id}/runs
- tasks → /api/tasks
- logs (nested) → /api/tasks/{task_id}/runs/{run_id}/logs

Classes:
- FirestoreClient: Agent-specific Firestore wrapper

RE-ACTIVATION PROCESS (if Firestore needed in future):
1. Copy this file back to src/agents/content_agent/services/firestore_client.py
2. Install google-cloud-firestore: pip install google-cloud-firestore
3. Set GCP_PROJECT_ID environment variable
4. Update content_agent to use FirestoreClient
5. Create Firestore collections in GCP
6. Test with Firestore emulator first

FULL ORIGINAL CODE:
"""

import os
import logging
from google.cloud import firestore
from datetime import datetime
from agents.content_agent.config import config
from typing import Optional, Any


class FirestoreClient:
    """
    Client for interacting with Google Cloud Firestore to log real-time agent status.
    
    MIGRATED TO: REST API (October 26, 2025)
    """

    def __init__(self):
        """
        Initializes the Firestore client using the project ID from the central config.
        """
        self.db = firestore.Client(project=config.GCP_PROJECT_ID)
        self.collection_name = config.FIRESTORE_COLLECTION
        self.run_collection_name = "agent_runs"  # New collection for logging runs
        self.task_collection_name = "tasks"  # Collection name for tasks
        logging.info("Firestore client initialized.")

    def log_run(self, task_id: str, topic: str, status: str = "Starting") -> str:
        """
        Logs the start of a new agent run and returns the Firestore document ID.
        MIGRATED TO: POST /api/tasks/{task_id}/runs

        Args:
            task_id (str): The Firestore document ID of the task.
            topic (str): The topic of the blog post.
            status (str): The initial status of the run.

        Returns:
            str: The unique ID of the Firestore document for this run.
        """
        try:
            run_data = {
                "task_id": task_id,
                "topic": topic,
                "status": status,
                "startedAt": datetime.utcnow(),
                "updatedAt": datetime.utcnow(),
                "history": [{"timestamp": datetime.utcnow(), "status": "Run Started"}],
            }
            doc_ref = self.db.collection(self.run_collection_name).add(run_data)
            run_id = doc_ref[1].id
            logging.info(f"Started and logged new run with ID: {run_id}")
            return run_id
        except Exception as e:
            logging.error(f"Failed to log new agent run: {e}")
            raise

    def update_run(
        self,
        run_id: str,
        status: Optional[str] = None,
        post_data: Optional[dict] = None,
    ):
        """
        Updates the status and other details of an ongoing agent run.
        MIGRATED TO: PUT /api/tasks/{task_id}/runs/{run_id}

        Args:
            run_id (str): The Firestore document ID of the run.
            status (str, optional): The new status to set.
            post_data (dict, optional): A dictionary of post-related data to merge.
        """
        if not run_id:
            logging.warning(
                "Update_run called with no run_id. Skipping Firestore update."
            )
            return

        try:
            doc_ref = self.db.collection(self.run_collection_name).document(run_id)
            update_data: dict[str, Any] = {"updatedAt": datetime.utcnow()}
            if status:
                update_data["status"] = status
                # Add a history entry for the status change
                update_data["history"] = firestore.ArrayUnion(
                    [{"timestamp": datetime.utcnow(), "status": status}]
                )

            if post_data:
                # Merge the post data into the document
                for key, value in post_data.items():
                    update_data[key] = value

            doc_ref.set(update_data, merge=True)
            logging.info(
                f"Updated Firestore run document '{run_id}' with status '{status}'."
            )
        except Exception as e:
            logging.error(f"Failed to update Firestore run document '{run_id}': {e}")

    def update_document(self, document_id: str, data: dict):
        """
        Creates or updates a document in the configured Firestore collection.
        MIGRATED TO: PUT /api/tasks/{task_id}

        Args:
            document_id (str): The ID of the document to create or update.
            data (dict): A dictionary of fields to set or merge.
        """
        try:
            doc_ref = self.db.collection(self.collection_name).document(document_id)
            # Add an 'updatedAt' timestamp to every update for better tracking
            data_with_timestamp = data.copy()
            data_with_timestamp["updatedAt"] = datetime.utcnow()
            doc_ref.set(data_with_timestamp, merge=True)
            logging.info(f"Updated Firestore document '{document_id}'.")
        except Exception as e:
            logging.error(f"Failed to update Firestore document '{document_id}': {e}")

    def get_content_queue(self) -> list[dict]:
        """
        Fetches all tasks from the 'tasks' collection with the status 'New'.
        MIGRATED TO: GET /api/tasks?status=New
        """
        try:
            tasks_ref = self.db.collection("tasks").where("status", "==", "New")
            docs = tasks_ref.stream()
            tasks = [{"id": doc.id, **doc.to_dict()} for doc in docs]
            logging.info(f"Found {len(tasks)} tasks in the content queue.")
            return tasks
        except Exception as e:
            logging.error(f"Failed to get content queue from Firestore: {e}")
            return []

    def update_task_status(
        self,
        task_id: str,
        status: str,
        url: Optional[str] = None,
        error_message: Optional[str] = None,
    ):
        """
        Updates the status of a specific task in the 'tasks' collection.
        MIGRATED TO: PUT /api/tasks/{task_id}
        """
        try:
            task_ref = self.db.collection("tasks").document(task_id)
            update_data = {"status": status, "updatedAt": datetime.utcnow()}
            if url:
                update_data["url"] = url
            if error_message:
                update_data["error_message"] = error_message
            task_ref.update(update_data)
            logging.info(f"Updated task '{task_id}' to status '{status}'.")
        except Exception as e:
            logging.error(
                f"Error updating task status in Firestore: {e}", exc_info=True
            )

    def add_log_to_run(self, run_id: str, level: str, message: str):
        """Adds a new log entry to a specific run's sub-collection.
        MIGRATED TO: POST /api/tasks/{task_id}/runs/{run_id}/logs
        """
        if not run_id:
            return
        try:
            log_data = {
                "timestamp": datetime.utcnow(),
                "level": level,
                "message": message,
            }
            self.db.collection(self.run_collection_name).document(run_id).collection(
                "logs"
            ).add(log_data)
        except Exception as e:
            logging.error(
                f"Error adding log to run {run_id} in Firestore: {e}", exc_info=True
            )

    def add_task(self, task_data: dict):
        """Adds a new task to the content-tasks collection.
        MIGRATED TO: POST /api/tasks
        """
        try:
            task_data["createdAt"] = datetime.utcnow()
            task_data["status"] = "Ready"
            self.db.collection(self.task_collection_name).add(task_data)
            logging.info(
                f"Successfully added new task to Firestore: {task_data['topic']}"
            )
        except Exception as e:
            logging.error(f"Error adding new task to Firestore: {e}", exc_info=True)
            raise
