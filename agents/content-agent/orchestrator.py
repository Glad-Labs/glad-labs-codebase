import os
import logging
import argparse
from config import config
from utils.logging_config import setup_logging
from utils.data_models import BlogPost
from services.strapi_client import StrapiClient
from services.firestore_client import FirestoreClient
from services.llm_client import LLMClient
from services.pexels_client import PexelsClient
from services.gcs_client import GCSClient
from agents.research_agent import ResearchAgent
from agents.creative_agent import CreativeAgent
from agents.image_agent import ImageAgent
from agents.qa_agent import QAAgent
from agents.publishing_agent import PublishingAgent

class Orchestrator:
    """
    The primary coordinator for the content generation pipeline.
    This class initializes all necessary clients and agents, and manages the
    end-to-end workflow from task retrieval to final publication.
    """
    def __init__(self):
        self.config = config
        self._setup_logging()
        logging.info("="*80)
        logging.info("INITIALIZING NEW ORCHESTRATOR RUN")
        logging.info("="*80)
        self._ensure_directories_exist()
        logging.info("Orchestrator initialized.")

    def _setup_logging(self):
        """Initializes the logging configuration for the application."""
        setup_logging()

    def _ensure_directories_exist(self):
        try:
            image_path = self.config.IMAGE_STORAGE_PATH
            if not os.path.exists(image_path):
                os.makedirs(image_path)
                logging.info(f"Created required directory: {image_path}")
        except OSError as e:
            logging.error(f"Fatal: Could not create directory {self.config.IMAGE_STORAGE_PATH}. Error: {e}")
            raise

    def run_batch_job(self):
        """
        Runs the content generation process in batch mode using Firestore as the task queue.
        """
        firestore_client = FirestoreClient()
        strapi_client = StrapiClient()

        tasks = firestore_client.get_content_queue()
        if not tasks:
            logging.info("No new content tasks found in Firestore.")
            return

        published_posts_map = strapi_client.get_all_published_posts()

        for task in tasks:
            blog_post = BlogPost(
                topic=task["topic"],
                primary_keyword=task["primary_keyword"],
                target_audience=task["target_audience"],
                category=task["category"],
                sheet_row_index=task.get("sheet_row_index", 0), # Legacy support
                task_id=task["id"]
            )
            self._process_post(blog_post, published_posts_map)

    def _process_post(self, post: BlogPost, published_posts_map: dict):
        """
        Manages the lifecycle of a single blog post from creation to publication.
        """
        firestore_client = FirestoreClient()
        strapi_client = StrapiClient()
        llm_client = LLMClient()
        pexels_client = PexelsClient()
        gcs_client = GCSClient()
        research_agent = ResearchAgent()
        creative_agent = CreativeAgent(llm_client)
        image_agent = ImageAgent(llm_client, pexels_client, gcs_client, strapi_client)
        qa_agent = QAAgent(llm_client)
        publishing_agent = PublishingAgent(strapi_client)
        
        post.published_posts_map = published_posts_map
        run_id = None
        
        try:
            if post.task_id:
                run_id = firestore_client.log_run(post.task_id, post.topic)
                firestore_client.update_task_status(post.task_id, "In Progress")
            
            logging.info(f"Processing post: '{post.topic}' (Task ID: {post.task_id}, Run ID: {run_id})")
            
            research_findings = research_agent.run(post.topic, post.primary_keyword.split(','))
            post.research_data = research_findings
            if run_id: firestore_client.update_run(run_id, status="Research Complete")

            approved = False
            for i in range(post.refinement_loops):
                post = creative_agent.run(post, is_refinement=(i > 0))
                if run_id: firestore_client.update_run(run_id, status=f"Draft {i+1} Created")
                
                if post.raw_content:
                    approved, qa_feedback = qa_agent.run(post, post.raw_content)
                    post.qa_feedback.append(qa_feedback)
                    if run_id: firestore_client.update_run(run_id, status=f"QA Review {i+1} Complete")
                else:
                    approved = False
                    qa_feedback = "No content was generated by the creative agent."
                    post.qa_feedback.append(qa_feedback)
                    logging.warning("Skipping QA check as no content was generated.")

                if approved:
                    break
            
            if not approved:
                raise Exception("Failed to produce satisfactory content.")

            post = image_agent.run(post)
            if run_id: firestore_client.update_run(run_id, status="Image Processing Complete")

            post = publishing_agent.run(post)
            
            if not post.strapi_url:
                raise Exception("Publishing failed to return a valid Strapi URL.")

            logging.info(f"Successfully published post: {post.strapi_url}")
            if run_id:
                firestore_client.update_run(run_id, status="Published", post_data={"strapi_url": post.strapi_url})
            if post.task_id:
                firestore_client.update_task_status(post.task_id, "Published", post.strapi_url)

        except Exception as e:
            error_message = f"An error occurred: {e}"
            logging.error(error_message, exc_info=True)
            if run_id:
                firestore_client.update_run(run_id, status="Failed", post_data={"error": error_message})
            if post.task_id:
                firestore_client.update_task_status(post.task_id, "Error")

if __name__ == "__main__":
    orchestrator = Orchestrator()
    orchestrator.run_batch_job()